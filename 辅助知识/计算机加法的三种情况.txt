6 - 4 = 2
6 + (-4) = 2

6
0000 0110

-4
1000 0100 原码
1111 1011 反码
1111 1100 补码

  0000 0110 6的补码
+ 1111 1100 -4的补码
-----------
 10000 0010 最高位溢出，2，是正确答案

  0000 0110 6的反码
+ 1111 1011 -4的反码
-----------
 10000 0001 最高位溢出，1，不是正确答案

、去掉溢出的最高位，是不是相当于减去2的n次方。相当于 mod 2的n次方 吧？
、6 ≡ 2 (mod 4)
、去掉溢出的最高位，表明是 mod 128，而不是 mod 127
	、反码不加一成补码的话，那就是 mod 127，而不是 mod 128 了。
、想象一个时钟，它有128格。6 - 4 = 2，相当于，将在第6格的指针，回拨4格，到第2格。或者，向前拨124格，最后指针也会落在第2格。从算术的角度来看，6 + 124 = 130 = 128 + 2，为了得到结果2，抹去128，相当于抛弃溢出的最高位。
	、说得不准确，128，1000 0000，最高位第八位是1，和-4的亦在第八位的符号位1，相加，导致最高位溢出，第八位归零，使得最后结果为正数。
------------------------------
1 - 6 = -5

-6
1000 0110 原码
1111 1001 反码
1111 1010 补码

  0000 0001
+ 1111 1010
-----------
  1111 1011

、1减去6，相当于加上122，得到123。123和-5同余，即 123 ≡ -5 (mod 128)，实际上想要的结果是 -5，而不是 123。所以，先减去1，再减去127(即减去0111 1111，相当于取反)，共减去128
、-133，-5，123，251，379......都对模 128 同余
	、这是不是在一定程度上，解释了为什么要如此定义 mod？或者说，为什么在取模的过程中，要对商往负无穷方向取整，是不是已有了较为明确的解释？
、如果补码相加的结果，小于128，说明实际结果肯定是负数，那么符号位1不会被加1导致溢出消失，进而使得最后结果符号位还是1。
------------------------------
-6 - 4 = -10
-6 + (-4) = -10

-6
1000 0110 原码
1111 1001 反码
1111 1010 补码

-4
1000 0100 原码
1111 1011 反码
1111 1100 补码

  1111 1010
+ 1111 1100
-----------
 11111 0110 最高位溢出
  1111 0101 上面是补码，减一，得到反码
  1000 1010 反码除符号位外，取反，得到原码

、可以认为，运算前，两个负数都加上了一个128，变成正数，到最后，要减去两个128才行。
	、忽略溢出后，最高位第八位是符号位，不计入值的大小，第一个128由此减去。
	、接着，减一，符号位不变取反，第二个128也被减去了
	、能顺利通过上面两步的最小值为 1000 0001，即 129，意味着，两个负数的之和，不能小于-127
